<!doctype html>
<html class="no-js" lang="en-us">

    <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BE1X04X1GG"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-BE1X04X1GG');
    </script>

    <meta charset="utf-8">
    <title>Agrest - Model-Driven REST Data Services</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Open source protocol and Java framework for model-driven REST data services. Works on top of JAX RS and integrates with various backends, such as Apache Cayenne.">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/fav/apple-touch-icon.png">
    <link rel="icon" type="images/png" sizes="32x32" href=" /images/fav/favicon-32x32.png">
    <link rel="icon" type="images/png" sizes="16x16" href=" /images/fav/favicon-16x16.png">
    <link rel="manifest" href= " /images/fav/site.webmanifest">
    <link rel="mask-icon" href=" /images/fav/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href=" /images/fav/favicon.ico">
    <link rel="me" href="https://mastodon.social/@andrus_a"/>
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-config" content=" /images/fav/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <title>agrest - Model-Driven REST Data Services</title>
    <link rel="canonical" href="https://agrest.io/docs/5.x/framework/" />

    <link href="" rel="stylesheet"><script src="/assets/app.js?e651377b7a1dff2662c3"></script>

</head>

    <body data-spy="scroll" data-target=".toc-side" class="cd-head" style="height: 100%; min-height: 100vh; padding-bottom: 70px;">

        
    <nav class="navbar navbar-expand-md navbar-light">
    <div class="container">
        <a class="navbar-brand" href="https://agrest.io/">
            <img src="/images/logo.svg" alt="agrest">
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#mainmenu" aria-controls="mainmenu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="mainmenu">
            <div class="navbar-right">
                <ul class="navbar-nav">

    
    <li class="nav-item">
        <a href="/" class="nav-link">Home</a>
    </li>

    <li class="nav-item">
        <a href="/docs/5.x/getting-started/" class="nav-link">Getting Started</a>
    </li>

    <li class="nav-item">
        <a href="/docs/5.x" class="nav-link">Documentation</a>
    </li>

    <li class="nav-item">
        <a href="https://groups.google.com/forum/?#!forum/agrest-user" class="nav-link">Forum</a>
    </li>


</ul>
                <ul class="navbar-nav" id="navbar-social-links">
                    <li class="nav-item"><a href="https://github.com/agrestio/agrest" class="nav-link"><img class="inline-svg icon-svg" src=" /images/fa/fab/github-brands.svg" alt="GitHub"></a></li>
                    <li class="nav-item"><a href="https://twitter.com/AgrestProject" class="nav-link"><img class="inline-svg icon-svg" src=" /images/fa/fab/twitter-brands.svg" alt="Twitter"></a></li>
                </ul>
            </div>
        </div>
    </div> 
</nav>
    <div class="navbar-overlay"></div>
    <div class="documentation-page container content docbook">
        <h1>
            Agrest Server Framework
        </h1>

            <div class="dropdown doc-version">
    <a class="dropdown-toggle" href="#" id="dropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" data-offset="-24,4">
        Version 5.x (alpha)
    </a>
    <div class="dropdown-menu" aria-labelledby="dropdownMenuLink">
            
                <a class="dropdown-item active" href="/docs/5.x/framework/">Version 5.x (alpha)</a>
            
            
                <a class="dropdown-item " href="/docs/4.x/framework/">Version 4.x (stable)</a>
            </div>
</div>

        <hr/>

        <div class="row mx-0">
            <div id="docs-nav" class="col-12 col-lg-4 col-xl-3 nav  docs-nav">
                <div class="tab-content" id="cd-docs-nav">
        
        
        
        
        
        <div class="cd-toc-item">
                                <span class="cd-toc-link active">Table of Contents</span><div id="toc" class="toc toc-side"> 
 <div id="toctitle">
  Table of Contents
 </div> 
 <ul class="sectlevel1 nav"> 
  <li><a href="#introduction" class="nav-link">1. Introduction</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#java-version" class="nav-link">1.1. Java Version</a></li> 
   </ul> </li> 
  <li><a href="#dependencies" class="nav-link">2. Dependencies</a></li> 
  <li><a href="#runtime" class="nav-link">3. Runtime</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#auto-loadable-modules" class="nav-link">3.1. Auto-Loadable Modules</a></li> 
   </ul> </li> 
  <li><a href="#schema" class="nav-link">4. Schema</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#schema-annotations" class="nav-link">4.1. Schema Annotations</a></li> 
    <li><a href="#external-metadata" class="nav-link">4.2. External Metadata</a></li> 
    <li><a href="#entity-overlays" class="nav-link">4.3. Entity Overlays</a></li> 
   </ul> </li> 
  <li><a href="#jersey-integration" class="nav-link">5. Jersey Integration</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#dependencies-2" class="nav-link">5.1. Dependencies</a></li> 
    <li><a href="#jersey-bootstrap" class="nav-link">5.2. Jersey Bootstrap</a></li> 
    <li><a href="#custom-extensions" class="nav-link">5.3. Custom Extensions</a></li> 
   </ul> </li> 
  <li><a href="#handling-requests" class="nav-link">6. Handling Requests</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#handler-flavors" class="nav-link">6.1. Handler Flavors</a></li> 
    <li><a href="#handlers-with-custom-stages" class="nav-link">6.2. Handlers with Custom Stages</a></li> 
   </ul> </li> 
  <li><a href="#get-requests" class="nav-link">7. GET Requests</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#get-a-single-object" class="nav-link">7.1. GET a Single Object</a></li> 
    <li><a href="#get-object-children" class="nav-link">7.2. GET Object Children</a></li> 
    <li><a href="#explicit-protocol-parameters" class="nav-link">7.3. Explicit Protocol Parameters</a></li> 
    <li><a href="#server-side-protocol-parameters" class="nav-link">7.4. Server-Side Protocol Parameters</a></li> 
    <li><a href="#customizing-entities" class="nav-link">7.5. Customizing Entities</a></li> 
    <li><a href="#property-visibility" class="nav-link">7.6. Property Visibility</a></li> 
    <li><a href="#object-visibility" class="nav-link">7.7. Object Visibility</a></li> 
   </ul> </li> 
  <li><a href="#post-requests" class="nav-link">8. POST Requests</a> 
   <ul class="sectlevel2 nav"> 
    <li><a href="#representation-of-create-data" class="nav-link">8.1. Representation of Create Data</a></li> 
    <li><a href="#customizing-entities-for-post" class="nav-link">8.2. Customizing Entities for POST</a></li> 
    <li><a href="#property-set-authorization" class="nav-link">8.3. Property Set Authorization</a></li> 
    <li><a href="#object-create-authorization" class="nav-link">8.4. Object Create Authorization</a></li> 
   </ul> </li> 
  <li><a href="#put-requests" class="nav-link">9. PUT Requests</a></li> 
  <li><a href="#delete-requests" class="nav-link">10. DELETE Requests</a></li> 
  <li><a href="#cayenne-integration" class="nav-link">11. Cayenne Integration</a></li> 
  <li><a href="#swagger-integration" class="nav-link">12. Swagger Integration</a></li> 
 </ul> 
</div></div>
        
        </div>
            </div>

            <div class="col-12 col-lg-8 col-xl-9  pb-3 pt-0 pl-lg-3">
                <article>
                    <div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Agrest provides a Java server framework for rapid development of RESTful data applications that are compatible with the
<a href="../protocol">Agrest Protocol</a>. The framework core is fully independent of specific data sources and REST engines.
Integrations with <a href="https://cayenne.apache.org/">Apache Cayenne ORM</a> and
<a href="https://en.wikipedia.org/wiki/Jakarta_RESTful_Web_Services">JAX-RS</a> (Jakarta and the older JavaEE) are included
out of the box, and a variety of custom backends can be integrated by the user.</p>
</div>
<div class="paragraph">
<p>Agrest apps can be run on <a href="../getting-started/">Spring Boot</a>, <a href="https://github.com/bootique/bootique-agrest">Bootique</a>
or any other environment. The framework plays well with other parts of the application - Agrest REST endpoints can
coexist with "regular" REST endpoints without a conflict.</p>
</div>
<div class="paragraph">
<p>Agrest is model-driven, with customizable "schema" that describes request and response entities. Agrest integrates
with Swagger to generate REST documentation in the widely-adopted <a href="https://swagger.io/specification/">OpenAPI 3</a> format.</p>
</div>
<div class="sect2">
<h3 id="java-version"><a class="anchor" href="#java-version"></a>1.1. Java Version</h3>
<div class="paragraph">
<p>Java 11 or newer is required.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependencies"><a class="anchor" href="#dependencies"></a>2. Dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we can start writing Agrest apps, we need to include the relevant modules as dependencies. The first
step is usually to import the common BOM (a so-called "bill of materials"), that will define the version of all
the other modules. It is placed in the <code>&lt;dependencyManagement/&gt;</code> section of the <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.agrest&lt;/groupId&gt;
    &lt;artifactId&gt;agrest-bom&lt;/artifactId&gt;
    &lt;!-- Replace with a specific 5.x version of Agrest --&gt;
    &lt;version&gt;${agrest.version}&lt;/version&gt;
    &lt;scope&gt;import&lt;/scope&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this out of the way, the rest of the document will show the use of individual Agrest dependencies without having
to worry about their version.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While all the build examples are Maven-based, Agrest apps most certainly can be assembled with  Gradle
or any other Java build tool you might prefer.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="runtime"><a class="anchor" href="#runtime"></a>3. Runtime</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>AgRuntime</code> object is the core of Agrest. It provides the strategies to process various types of requests, stores
the app data "schema", and serves as an integration point for various data backends. When working in the
environments like <a href="#jersey-integration">Jersey / JAX-RS</a>, you may not be interacting with <code>AgRuntime</code> directly, but it
is still the object doing all the heavy lifting under the hood. And you will still need to assemble the runtime
before you can use Agrest.</p>
</div>
<div class="paragraph">
<p>This is how you create a bare-bone default runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgRuntime agRuntime = AgRuntime.build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usually you would add at least one backend provider though (such as
<a href="#cayenne-integration">Apache Cayenne</a>), and often - your own extensions. Internally <code>AgRuntime</code> uses a lightweight
dependency-injection container to assemble its services, and can be extended using "modules":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgRuntime agRuntime = AgRuntime
        .builder()
        .module(b -&gt; b <i class="conum" data-value="1"></i><b>(1)</b>
                .bindMap(JsonValueConverter.class)
                .put(MoneyConverter.class.getName(), MoneyConverter.class))
        .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registering a module with support for a custom value type of <code>Money</code>, providing a converter for it to be read from
JSON. <code>b</code> is a special <code>Binder</code> object that allows to define or override services in the DI environment.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To see what kinds of services and extensions are available and how to use the Binder API, you may
check the source code of <code>io.agrest.runtime.AgCoreModule</code> on GitHub. This is the main module of Agrest, and defines the
default behavior for the framework.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="auto-loadable-modules"><a class="anchor" href="#auto-loadable-modules"></a>3.1. Auto-Loadable Modules</h3>
<div class="paragraph">
<p>More complex Agrest extensions may be packaged in their own <code>.jar</code> files. Agrest has a mechanism to automatically detect
such jars on the classpath, load and merge them into the runtime. To turn your code into an auto-loadable module, add a
file called <code>META-INF/services/io.agrest.AgModuleProvider</code> to the classpath of your project (usually under
<code>src/main/resources</code>), with a single line that is a fully-qualified class name of the <code>AgModuleProvider</code> implementor.
E.g. the same extension as above can be rewritten to be auto-loadable:</p>
</div>
<div class="listingblock">
<div class="title">META-INF/services/io.agrest.AgModuleProvider</div>
<div class="content">
<pre class="highlight"><code>com.foo.MyModuleProvider</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MyModuleProvider implements AgModuleProvider {

    @Override
    public Module module() {
        return new MyModule();
    }

    @Override
    public Class&lt;? extends Module&gt; moduleType() {
        return MyModule.class;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MyModule implements Module {

    @Override
    public void configure(Binder binder) {
        binder
                .bindMap(JsonValueConverter.class)
                .put(MoneyConverter.class.getName(), MoneyConverter.class);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may not be writing auto-loadable modules that often for "normal" applications, as it is much easier to create
inline modules. But this is a useful mechanism for creating reusable Agrest extensions.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schema"><a class="anchor" href="#schema"></a>4. Schema</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Agrest has a metadata management service called <code>AgSchema</code> with access to models of app data
objects, each represented by an <code>AgEntity</code> instance. Each entity contains properties. Those can be one of <code>id</code>,
<code>attribute</code> or <code>relationship</code>. Entity and property models define names, data types and data retrieval and access control
strategies. Here is how you can obtain an <code>AgSchema</code> singleton, entities and properties in runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgSchema schema = runtime.service(AgSchema.class); <i class="conum" data-value="1"></i><b>(1)</b>
AgEntity&lt;Book&gt; bookEntity = schema.getEntity(Book.class); <i class="conum" data-value="2"></i><b>(2)</b>
AgAttribute titleAttribute = bookEntity.getAttribute("title"); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>AgSchema</code> object is a "service" within the Agrest runtime</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>AgEntity</code> is a REST API model corresponding to a specific Java class</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>AgAttribute</code> is one of the 3 property types in the entity model. Among other things it contains a "reader",
i.e. resolution strategy.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As a developer, you&#8217;d rarely use <code>AgSchema</code> directly. But you still need to define how the schema looks like for
the benefit of Agrest runtime. More on this below.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Even though schemas are usually associated with specific Java classes (such as <code>Book</code> or <code>Author</code>), they are not
necessarily identical to the structure of those classes, as they represent the client view of the data. Some object
properties may be excluded from the REST API, others may be "virtual" and have no match in the object itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s looks at the various ways to define the schema in the app. Those are <a href="#schema-annotations">Ag annotations</a>,
<a href="#external-metadata">external metadata</a> and <a href="#entity-overlays">entity overlays</a>. These three approaches are
complimentary and can be combined with each other.</p>
</div>
<div class="sect2">
<h3 id="schema-annotations"><a class="anchor" href="#schema-annotations"></a>4.1. Schema Annotations</h3>
<div class="paragraph">
<p><code>@AgId</code>, <code>@AgAttribute</code> and <code>@AgRelationship</code> annotations are used to define which object properties should be included
in the default Agrest model. They are applied to "getter" methods of Java classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Book {

    private long id;
    private String title;
    private String publishStatus;
    private Author author;

    @AgId <i class="conum" data-value="1"></i><b>(1)</b>
    public long getId() {
        return id;
    }

    @AgAttribute(writable = false) <i class="conum" data-value="2"></i><b>(2)</b>
    public String getTitle() {
        return title;
    }

    @AgRelationship <i class="conum" data-value="3"></i><b>(3)</b>
    public Author getAuthor() {
        return author;
    }

    public Book setId(long id) {
        this.id = id;
        return this;
    }

    public Book setTitle(String title) {
        this.title = title;
        return this;
    }

    public Book setAuthor(Author author) {
        this.author = author;
        return this;
    }

    public Book setPublishStatus(String publishStatus) {
        this.publishStatus = publishStatus;
        return this;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Tags the property as an id</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Tags the property as an attribute (i.e. the property that is a "value"). Read-only policy is defined.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Tags the property as a relationship (i.e. the property pointing to another entity)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="external-metadata"><a class="anchor" href="#external-metadata"></a>4.2. External Metadata</h3>
<div class="paragraph">
<p>With some Agrest backends, an <code>AgSchema</code> can be auto-generated from another preexisting backend-provided schema. E.g.
Apache Cayenne ORM backend automatically compiles <code>AgSchema</code> that directly corresponds to the Cayenne ORM model.
Application can then customize it <a href="#schema-annotations">via annotations</a>
(e.g. <code>@AgAttribute(readable=false,writable=false)</code> allows to hide a certain property from the REST API),
or via <a href="#entity-overlays">entity overlays</a> discussed next, but the bulk of the schema is created without any explicit
effort on the part of the developer.</p>
</div>
<div class="paragraph">
<p>If you are writing your own backend integration, and there is a preexisting schema you&#8217;d like Agrest to use, you can
implement your own "entity compiler":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyEntityCompiler implements AgEntityCompiler {

    @Override
    public &lt;T&gt; AgEntity&lt;T&gt; compile(Class&lt;T&gt; aClass, AgSchema agSchema) {

        return isHandledByMyBackend(aClass)
                ? doCompile(aClass, agSchema) <i class="conum" data-value="1"></i><b>(1)</b>
                : null; <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the class should be handled by our custom backend, generate an <code>AgEntity</code> in some
backend-specific way</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the class is not recognized, return null to give some other compiler a chance to provide the schema</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is how to register the compiler with Agrest runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgRuntime runtime = AgRuntime
        .builder()
        .module(b -&gt; b
                .bindList(AgEntityCompiler.class)
                .insertBefore(MyEntityCompiler.class, AnnotationsAgEntityCompiler.class))
        .build();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entity-overlays"><a class="anchor" href="#entity-overlays"></a>4.3. Entity Overlays</h3>
<div class="paragraph">
<p>Entity overlays is a manual way to tweak the entities in the schema. As the name implies, overlays are used to
change the structure of the existing entities, that were compiled from annotations or via some other mechanism.
Overlays is a somewhat verbose, but rather versatile mechanism frequently used in applications. Here is an example of
an overlay:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgEntityOverlay&lt;Author&gt; overlay = AgEntity
        .overlay(Author.class)
        .attribute( <i class="conum" data-value="1"></i><b>(1)</b>
                "age",
                Integer.TYPE,
                a -&gt; Period.between(a.getDateOfBirth(), LocalDate.now()).getYears())
        .writablePropFilter(p -&gt; p.property("dateOfBirth", false)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adds a new calculated attribute called "age"</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Adds a policy forbidding changing "dateOfBirth" attribute</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Overlays can be applied globally, affecting the entire runtime. Here they redefine the schema that was created
from annotations or from external metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgRuntime runtime = AgRuntime
        .builder()
        .entityOverlay(overlay)
        .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Overlays can
also be applied per-request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AgJaxrs.select(Book.class, config).entityOverlay(overlay).get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way dynamically-generated overlays can shape the entities based on some request data, such as user permissions.
And indeed, per-request Agrest <a href="#Access Control">access control</a> methods are internally implemented as entity overlays.</p>
</div>
<div class="paragraph">
<p>Another thing to notice here, is that overlay doesn&#8217;t need to be of the same type as the root
entity of the request. In the example above, the request is for <code>Book</code>, while overlay is for <code>Author</code>. So it will be applied in
case the request contains <code>include=author</code> control parameter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jersey-integration"><a class="anchor" href="#jersey-integration"></a>5. Jersey Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jersey is often used to run Agrest applications. It supports Java API for RESTful services (JAX-RS).
Agrest works with either the legacy Jersey 2 (<code>agrest-jaxrs2</code> module) or the Jakarta-based Jersey 3 (<code>agrest-jaxrs3</code> module).
Their main difference is JAX-RS package names (<code>javax.</code> vs <code>jakarta.</code>). We will provide Jersey 3 examples below, but
they should equally apply to Jersey 2, and for the most part work with other JAX-RS servers.</p>
</div>
<div class="paragraph">
<p>Jersey doesn&#8217;t run standalone until at least version 3.1, and requires some kind of Java "server", such as Jetty,
Spring Boot, Bootique, etc. Examples of server integrations are provided in the links below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest3x/index.html">Jersey 3 own docs</a></p>
</li>
<li>
<p><a href="../getting-started/">Spring Boot 2.x Agrest tutorial</a> (Jersey 2 only)</p>
</li>
<li>
<p><a href="https://github.com/bootique/bootique-jersey">Bootique Jersey</a>, or even better -
<a href="https://github.com/bootique/bootique-agrest">Bootique Agrest</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the rest of this document we will focus on Agrest usage in the Jersey environment, ignoring the underlying server.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SpringBoot: SpringBoot 2.x supports Jersey 2, while SpringBoot 3.x will support Jersey 3
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Bootique Note: Bootique 2.x supports Jersey 2, while Bootique 3.x supports both Jersey 2 and 3
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="dependencies-2"><a class="anchor" href="#dependencies-2"></a>5.1. Dependencies</h3>
<div class="paragraph">
<p>You may or may not need to explicitly import Jersey dependencies, depending on how you are planning to run it (see
above). But you will need the following Agrest import:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.agrest&lt;/groupId&gt;
    &lt;artifactId&gt;agrest-jaxrs3&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jersey-bootstrap"><a class="anchor" href="#jersey-bootstrap"></a>5.2. Jersey Bootstrap</h3>
<div class="paragraph">
<p>Jersey provides a convenience superclass called <code>ResourceConfig</code> that you can subclass and bootstrap your application
in the constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AgrestJerseyApp extends ResourceConfig { <i class="conum" data-value="1"></i><b>(1)</b>

    public AgrestJerseyApp() {

        <i class="conum" data-value="2"></i><b>(2)</b>
        AgRuntime runtime = AgRuntime
                .builder()
                // add backend configurations and runtime extensions
                // .module(...)
                .build();

        <i class="conum" data-value="3"></i><b>(3)</b>
        AgJaxrsFeature agJaxRs = AgJaxrsFeature.build(runtime);
        super.register(agJaxRs);

        <i class="conum" data-value="4"></i><b>(4)</b>
        super.register(AuthorApi.class);
        super.register(BookApi.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The app class extending Jersey <code>ResourceConfig</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create Agrest runtime, as described in the <a href="#runtime">Runtime</a> section</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Register Agrest runtime with Jersey / JAX-RS environment</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Register your app API endpoints with Jersey (we will see these endpoint classes shortly)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="custom-extensions"><a class="anchor" href="#custom-extensions"></a>5.3. Custom Extensions</h3>
<div class="paragraph">
<p>TODO: JAX-RS extensions via <code>AgFeatureProvider</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="handling-requests"><a class="anchor" href="#handling-requests"></a>6. Handling Requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Agrest runtime provides handlers for the various types of HTTP requests (<a href="#get-requests">GET</a>, <a href="#post-requests">POST</a>,
<a href="#put-requests">PUT</a>, <a href="#delete-requests">DELETE</a>). We will discuss each
one individually in the following chapters. Here we&#8217;ll look at general principles of request handling.</p>
</div>
<div class="paragraph">
<p>Below is a typical JAX-RS endpoint implemented with Agrest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Path("author")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AuthorApi {

    @Context
    private Configuration config; <i class="conum" data-value="1"></i><b>(1)</b>

    @GET
    public DataResponse&lt;Author&gt; get(@Context UriInfo uri) { <i class="conum" data-value="2"></i><b>(2)</b>
        return AgJaxrs
                .select(Author.class, config) <i class="conum" data-value="3"></i><b>(3)</b>
                .clientParams(uri.getQueryParameters())
                .get();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>JAX-RS <code>Configuration</code> is injected using JAX-RS <code>@Context</code> annotation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One way to collect protocol parameters for the request is via JAX-RS <code>UriInfo</code> injection</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>AgJaxrs</code> is a helper that locates the <code>AgRuntime</code> within the <code>Configuration</code> and starts an Agrest processor</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Agrest tries to stay maximally non-invasive within the app. You can mix Agrest endpoints with non-Agrest
endpoints, and even within the endpoint you can execute any custom code.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="handler-flavors"><a class="anchor" href="#handler-flavors"></a>6.1. Handler Flavors</h3>
<div class="paragraph">
<p>Requests are handled by starting a request-appropriate builder via <code>AgJaxrs</code>, which is then configured with client
request parameters, client body, custom entity schemas, access rules, etc., and then executed. Below are the main types
of handlers:</p>
</div>
<div class="paragraph">
<p><em>Select handler.</em> Returns <code>DataResponse&lt;T&gt;</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; get(@Context UriInfo uri) {
    return AgJaxrs
            .select(Author.class, config)
            .clientParams(uri.getQueryParameters())
            .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>"Simple" update handler.</em> Creates and/or updates data, returning <code>SimpleResponse</code>. <code>create</code> handler is shown
in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public SimpleResponse create(String entityData) {
    return AgJaxrs
            .create(Author.class, config)
            .sync(entityData);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Updating handlers have a variety of flavors for idempotent and non-idempotent requests. We&#8217;ll discuss them in the
chapters on <a href="#post-requests">POST</a> and <a href="#put-requests">PUT</a> requests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>"Selecting" update handler.</em> Creates and/or updates data, returning <code>DataResponse&lt;T&gt;</code> with the objects
that where modified. It is identical to the "simple" handler, except you&#8217;d call <code>syncAndSelect</code> at the end
instead of <code>sync</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public DataResponse&lt;Author&gt; createWithData(@Context UriInfo uri, String entityData) {
    return AgJaxrs
            .create(Author.class, config)
            .clientParams(uri.getQueryParameters())
            .syncAndSelect(entityData);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Unrelate handler.</em> Breaks a relationship between entities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PUT
@Path("{id}")
public SimpleResponse unrelate(@PathParam("id") long id) {
    return AgJaxrs
            .unrelate(Author.class, config)
            .sourceId(id)
            .allRelated("books")
            .sync();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Delete handler</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@DELETE
@Path("{id}")
public SimpleResponse delete(@PathParam("id") long id) {
    return AgJaxrs
            .delete(Author.class, config)
            .byId(id)
            .sync();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handlers-with-custom-stages"><a class="anchor" href="#handlers-with-custom-stages"></a>6.2. Handlers with Custom Stages</h3>
<div class="paragraph">
<p>TODO&#8230;&#8203;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-requests"><a class="anchor" href="#get-requests"></a>7. GET Requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With just a few lines of code, Agrest can process <code>GET</code> requests conforming to
<a href="../protocol#control-parameters">Agrest protocol</a>. Here is how you may program a request handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; get(@Context UriInfo uri) {
    return AgJaxrs.select(Author.class, config) <i class="conum" data-value="1"></i><b>(1)</b>
            .clientParams(uri.getQueryParameters()) <i class="conum" data-value="2"></i><b>(2)</b>
            .get(); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Start "select" operation builder</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pass all request parameters from JAX-RS <code>UriInfo</code> object. The framework will process those that are defined in the
Agrest protocol (<code>exp</code>, <code>include</code>, etc.) and ignore the rest</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Execute the select operation</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="get-a-single-object"><a class="anchor" href="#get-a-single-object"></a>7.1. GET a Single Object</h3>
<div class="paragraph">
<p>Often a REST API would only return a single object matching a given <code>id</code>. Here is how this can be implemented in Agrest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
@Path("{id}")
public DataResponse&lt;Author&gt; getById(
        @PathParam("id") long id,  <i class="conum" data-value="1"></i><b>(1)</b>
        @Context UriInfo uri) {
    return AgJaxrs.select(Author.class, config)
            .byId(id) <i class="conum" data-value="2"></i><b>(2)</b>
            .clientParams(uri.getQueryParameters())
            .getOne(); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"id" may be modeled as a part of the URL path and injected via JAX-RS <code>@PathParam</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here is how the "id" is passed to the Agrest operation builder</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Instead of <code>get()</code>, call <code>getOne()</code> to execute the operation. It still returns the same <code>DataResponse</code>, but
will handle cases when there is no matching object found (<code>404</code> response status code instead of <code>200</code>) and also when
more than one object is found (this will result in <code>500</code> status code).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="get-object-children"><a class="anchor" href="#get-object-children"></a>7.2. GET Object Children</h3>
<div class="paragraph">
<p>Another common pattern in a REST API design is hierarchical resource URLs used to retrieve "children" of a given
"parent" object. E.g. the books of a single known author:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
@Path("{author_id}/books") <i class="conum" data-value="1"></i><b>(1)</b>
public DataResponse&lt;Book&gt; booksForAuthor(
        @PathParam("author_id") long authorId, <i class="conum" data-value="2"></i><b>(2)</b>
        @Context UriInfo uri) {

    return AgJaxrs.select(Book.class, config)
            .parent(Author.class, authorId, "books") <i class="conum" data-value="3"></i><b>(3)</b>
            .clientParams(uri.getQueryParameters())
            .get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define a URL path with author ID and relationship name</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Capture author ID as a <code>@PathParam</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set the "parent" object of the request</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
"Parent" API is just syntactic sugar to support hierarchical resource URLs like <code>/author/576/books</code>. Similar
functionality can also be implemented as <code>/book?exp=author=576</code> or <code>/author/576?include=books</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="explicit-protocol-parameters"><a class="anchor" href="#explicit-protocol-parameters"></a>7.3. Explicit Protocol Parameters</h3>
<div class="paragraph">
<p>Not every endpoint has to support every single protocol parameter. Depending on the application needs (and backend
capabilities), you may explicitly define which parameters are supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; getIncludeAndSort(
        @QueryParam(ControlParams.INCLUDE) List&lt;String&gt; includes,  <i class="conum" data-value="1"></i><b>(1)</b>
        @QueryParam(ControlParams.SORT) String sort,
        @QueryParam(ControlParams.DIRECTION) String direction) {

    AgRequest request = AgJaxrs.request(config) <i class="conum" data-value="2"></i><b>(2)</b>
            .addIncludes(includes)
            .addSort(sort, direction)
            .build();

    return AgJaxrs.select(Author.class, config)
            .request(request) <i class="conum" data-value="3"></i><b>(3)</b>
            .get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of <code>UriInfo</code>, capture individual query parameters using <code>@QueryParam</code> annotation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Build a <code>AgRequest</code> object with all the passed parameters</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass the <code>AgRequest</code> to the operation builder</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="server-side-protocol-parameters"><a class="anchor" href="#server-side-protocol-parameters"></a>7.4. Server-Side Protocol Parameters</h3>
<div class="paragraph">
<p>The <code>AgRequest</code> object has another useful property. Unlike <code>UriInfo</code> that captures everything that was passed in the
URL by the client, it is manually constructed <strong>on the server</strong>. So you can amend the request object in your application
code to limit what the client can do or to define the default data appearance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; getModernAuthors(
        @QueryParam(ControlParams.INCLUDE) List&lt;String&gt; includes,
        @QueryParam(ControlParams.EXP) String urlExp) {

    AgRequest request = AgJaxrs.request(config)
            .addIncludes(includes)
            .andExp(Exp.greaterOrEqual("dateOfBirth", LocalDate.of(1970, 1, 1))) <i class="conum" data-value="1"></i><b>(1)</b>
            .andExp(urlExp) <i class="conum" data-value="2"></i><b>(2)</b>
            .addSort("name", "asc") <i class="conum" data-value="3"></i><b>(3)</b>
            .build();

    return AgJaxrs.select(Author.class, config)
            .request(request)
            .get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Pass an expression limiting the dataset. The client will not be able to override this filter, and can only narrow
the dataset further by using the URL <code>exp</code> parameter (see the next item)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Combine the server-side expression with a client expression that came from the URL</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Define data ordering (and do not allow the client to change it)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="customizing-entities"><a class="anchor" href="#customizing-entities"></a>7.5. Customizing Entities</h3>
<div class="paragraph">
<p>As already mentioned in the chapter on <a href="#entity-overlays">Entity Overlays</a>, you can redefine the shape of entities,
their retrieval strategies and access rules via per-request overlays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; getWithOverlay(@Context UriInfo uri) {

    SelectBuilder&lt;Author&gt; builder = AgJaxrs
            .select(Author.class, config)
            .clientParams(uri.getQueryParameters());

    if (!isAdminRole()) {  <i class="conum" data-value="1"></i><b>(1)</b>

        AgEntityOverlay&lt;Book&gt; bookModelChanges = AgEntity
                .overlay(Book.class)
                .readablePropFilter(b -&gt; b.property("copiesSold", false));

        builder.entityOverlay(bookModelChanges); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    return builder.get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Hide an attribute using an overlay if the request user is not an administrator</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apply the overlay to the request</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While the request is for the <code>Author</code> entity, overlays can be for any entity at all (including the <code>Author</code>). In our
case the overlay is for the <code>Book</code>, meaning that it will be applied if the user runs a request like <code>/author?include=books</code>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="property-visibility"><a class="anchor" href="#property-visibility"></a>7.6. Property Visibility</h3>
<div class="paragraph">
<p>There&#8217;s a more direct API to implement per-request property visibility rules. It can also be applied to any entity in
the request graph, not just the root entity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; getWithPropFilter(@Context UriInfo uri) {

    SelectBuilder&lt;Author&gt; builder = AgJaxrs
            .select(Author.class, config)
            .clientParams(uri.getQueryParameters());

    if (!isAdminRole()) {
        builder.propFilter(Book.class, pfb -&gt; pfb.property("copiesSold", false)); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    return builder.get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Apply "property filter" for non-admin users to the Book entity, hiding "copiesSold" property from the response objects</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally property filter is implemented as an overlay, similar to the previous example, but from the user perspective
the filter API is less verbose.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Don&#8217;t forget that you can also define readability rules for individual properties globally using <code>@AgAttribute</code>
annotation (see <a href="#schema-annotations">Schema Annotations</a>)
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="object-visibility"><a class="anchor" href="#object-visibility"></a>7.7. Object Visibility</h3>
<div class="paragraph">
<p>The previous examples shows how you can hide certain <em>properties</em> based on per-request custom logic. Similarly,
you can exclude certain <em>objects</em> from the response with custom "read filters":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GET
public DataResponse&lt;Author&gt; getWithReadFilter(@Context UriInfo uri) {

    SelectBuilder&lt;Author&gt; builder = AgJaxrs
            .select(Author.class, config)
            .clientParams(uri.getQueryParameters());

    if (isModernAuthorsOnly()) {
        LocalDate threshold = LocalDate.of(1970, 1, 1);
        builder.filter(Author.class, a -&gt; a.getDateOfBirth().isAfter(threshold) ); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    return builder.get();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If only modern authors are requested, apply a "read filter" to exclude older authors. The filter lambda must
return "true" for the objects that pass the check and should be included in the response.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If custom object filtering rules can be written as an <code>Exp</code> on the root entity, consider doing that instead of
using a read filter. It would move the filtering logic to the data store and out of your code, potentially
optimizing the processing. You can refer to an example above from the <a href="#server-side-protocol-parameters">Server-Side Protocol Parameters</a> chapter.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="post-requests"><a class="anchor" href="#post-requests"></a>8. POST Requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Agrest works with REST resources that represent data entities. For such resources, <code>POST</code> requests are used to <em>create</em>
new entities in a <em>non-idempotent way</em>. In practice, it means that created entity id is not known to the client upfront,
and will be generated on the server. The simplest POST handler may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public SimpleResponse createAndForget(String data) { <i class="conum" data-value="1"></i><b>(1)</b>
    return AgJaxrs.create(Author.class, config) <i class="conum" data-value="2"></i><b>(2)</b>
            .sync(data); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Author entity data is accepted as a String. The String must contain JSON and must conform to the Agrest Protocol
<a href="../protocol#update-request">Update Document</a> format, i.e. be either a single object or a collection of objects.
Object properties should match the properties of the created entity. Here is an example of a single object payload:
<code>{"name":"Ernest Hemingway","dateOfBirth":"1899-07-21"}</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start "create" operation builder</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call "sync" that will execute the "create" operation and return a "simple" response</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Such "create-and-forget" style of <code>POST</code> is rarely used, as the client usually needs to know the server-generated id
of the created entity or entities. Instead, you could use a "selecting" flavor that returns back the created object(s),
combining create and select in one call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public DataResponse&lt;Author&gt; createAndSelect(String data) {
    return AgJaxrs.create(Author.class, config)
            .syncAndSelect(data); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of "sync", call "syncAndSelect"</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just like <a href="#get-requests">GET</a>, such requests can take Agrest protocol parameters to shape, filter and order the response
collection. "Read" object and property filters can also be applied to them, just like with GET.</p>
</div>
<div class="sect2">
<h3 id="representation-of-create-data"><a class="anchor" href="#representation-of-create-data"></a>8.1. Representation of Create Data</h3>
<div class="paragraph">
<p>We&#8217;ve already seen how to pass object data to Agrest as a JSON String representing either a single object, or a
collection of objects per Agrest Protocol <a href="../protocol#update-request">Update Document</a> format. Alternatively,
each JSON object can be represented as an <code>EntityUpdate&lt;T&gt;</code>. E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public DataResponse&lt;Author&gt; createWithEntityUpdate(
        EntityUpdate&lt;Author&gt; authorUpdate) { <i class="conum" data-value="1"></i><b>(1)</b>

    return AgJaxrs.create(Author.class, config)
            .syncAndSelect(authorUpdate);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of a String, pass <code>EntityUpdate&lt;Author&gt;</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, a collection of updates can be passed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@POST
public DataResponse&lt;Author&gt; createWithEntityUpdates(
        List&lt;EntityUpdate&lt;Author&gt;&gt; authorUpdates) { <i class="conum" data-value="1"></i><b>(1)</b>

    return AgJaxrs.create(Author.class, config)
            .syncAndSelect(authorUpdates);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of a String, pass <code>List&lt;EntityUpdate&lt;Author&gt;&gt;</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There&#8217;s no functional difference between using Strings or EntityUpdates. In both cases Agrest performs the same operation.
But <code>EntityUpdate</code> has other advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It makes the expected payload of your REST method more explicit (e.g. for the purpose of generating OpenAPI documentation)</p>
</li>
<li>
<p>It allows to distinguish between endpoints that can process just a single object vs. those that process collections</p>
</li>
<li>
<p>It allows to tweak the client request in your server-side code</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
String and EntityUpdate data formats are used in the same way across all handlers that create or modify entities,
and both POST and PUT requests.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="customizing-entities-for-post"><a class="anchor" href="#customizing-entities-for-post"></a>8.2. Customizing Entities for POST</h3>

</div>
<div class="sect2">
<h3 id="property-set-authorization"><a class="anchor" href="#property-set-authorization"></a>8.3. Property Set Authorization</h3>

</div>
<div class="sect2">
<h3 id="object-create-authorization"><a class="anchor" href="#object-create-authorization"></a>8.4. Object Create Authorization</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="put-requests"><a class="anchor" href="#put-requests"></a>9. PUT Requests</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="delete-requests"><a class="anchor" href="#delete-requests"></a>10. DELETE Requests</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="cayenne-integration"><a class="anchor" href="#cayenne-integration"></a>11. Cayenne Integration</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="swagger-integration"><a class="anchor" href="#swagger-integration"></a>12. Swagger Integration</h2>
<div class="sectionbody">

</div>
</div>
                </article>
            </div>

        </div>
    </div>


        <footer id="footer" class="pt-0 pb-3" style ="bottom: 0px; position: absolute; width: 100%;">
    <div class="container">
        <div class="row justify-content-center text-center">
            <div class="col-8 col-md-12">
                <p class="text-muted">&copy;  <span class="current-year">2018</span> ObjectStyle and other Agrest Developers.</p>
                <ul id="social-icons" class="list-unstyled list-inline  mb-0">
                    <li class="list-inline-item">
                        <a href="https://github.com/agrestio/agrest">
                            <img class="inline-svg" src="/images/fa/fab/github-brands.svg" alt="github logo"/>
                        </a>
                    </li>
                    <li class="list-inline-item">
                        <a href="https://twitter.com/AgrestProject">
                            <img class="inline-svg" src="/images/fa/fab/twitter-brands.svg" alt="twitter logo"/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>

    </body>
</html>